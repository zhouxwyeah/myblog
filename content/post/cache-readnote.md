---
# 常用定义
title: "缓存阅读笔记"           # 标题
date: 2019-04-08T10:01:23+08:00    # 创建时间
lastmod: 2019-04-08T10:01:23+08:00 # 最后修改时间
draft: true                       # 是否是草稿？
tags: ["cache"]  # 标签
categories: ["tech"]              # 分类
author: "zhouxwyeah"                  # 作者
description: "缓存设计笔记"
# 用户自定义
# 你可以选择 关闭(false) 或者打开(true) 以下选项
comment: true   # 关闭评论
toc: true       # 关闭文章目录
# 你同样可以自定义文章的版权规则
reward: false	 # 关闭打赏
mathjax: true    # 打开 mathjax

---

本文关于缓存方面的阅读笔记，希望通过本文理清关于缓存设计的一些思路，并参考当前一些java cache的现有方案。

> 缓存通常是提升性能的一个通用手段，并且大部分实现都严格基于经典的技术

#### 缓存的要求

* 支持高并发,良好的并发性能
* 内存大小可限制
* 扩展性强，如果需求增加，可以方便的scale
* 命中率高
* 处理好雪崩，穿透等特殊情况
* 分布式缓存

#### 缓存算法

* FIFO 先进先出  无法保证命中率
* LRU 算是最通用的做法，默认认为缓存命中率和使用历史关联，每次读写都影响排名
* LFU 最小频率优先淘汰，单独维护一个位图，判断使用次数
* W-LRU

#### 通用的做法

* ConcurrentHashMap   无法支持内存可控，并发通过lock-strip解决，16把锁

* LRUMap   